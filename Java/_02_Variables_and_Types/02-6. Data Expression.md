## Java의 데이터 표현
- `int`와 `long`이 나누어지는 이유
    - 사용하는 0과 1의 개수가 다름


- 변수를 선언하는 것은 컴퓨터 메모리 상에 변수가 들어갈 공간을 확보하는 것
    - 자료형에 따라 0과 1을 표현할 수 있는 공간이 확보된다.
    - `int` : 4byte(32bit)
    - `long` : 8byte(64bit)

### 정수 부호 표현
1. 절대값을 2진수로 표현
```text
-14 => 14 => 1110
```

2. (8비트 사용 가정) 남은 비트 0으로 채움
```text
1110 => 0000 1110 
```

3. 각 비트가 0이면 1, 1이면 0으로 변환
```text
0000 1110 => 1111 0001
```

4. 결과에 1을 더함
```text
1111 0001 => 1111 0010
```

- 이렇게 표현된 음수는 동일한 절대값의 음수와 더했을 때 0
```text
 14 = 0000 1110
-14 = 1111 0010
------------------
    1 0000 0000
```
- 8비트만 저장하기 때문에, 오버플로우가 일어난 비트는 버려지고 최종적으로 0이 됨

### 실수 부동 소숫점
- 부동 소숫점(floating point)
1. 실수를 2진수로 변환
```text
10.25 => 1010.01
```
2. 정수부가 한자리만 남도록 이동, 이동한 만큼 2의 거듭제곱으로 표현(정규화)
```text
1010.01 =>    1.01001   *    2^3
           유효숫자(가수)
```
3. 지수에 Bias를 더함(지수가 음수일 경우 양수로 변환하기 위해)
```text
3 + 127 => 130 => 1000 0010
```
- Bias = 2^(e-1)-1 (e는 지수 비트의 개수)
  - 위에서 지수는 3
  - bias = 2^(8-1)-1 = 2^7 -1 = 128 -1 = 127
4. 부호를 부호비트에,지수를 지수부에, 유효숫자를 가수부에 저장
```text
(부호)    (지수)              (가수)
0    - 1000 0010 - 010 0100 0000 0000 0000 0000
```
- 가수는 정규화되어 제일 높은 자리는 무조건 1이므로 생략
- double과 float은 표현 방식은 동일하지만 double이 공간을 2배 더 차지해 정밀한 저장이 가능